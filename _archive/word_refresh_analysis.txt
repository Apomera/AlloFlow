=== WORD SOUNDS REFRESH/REGENERATE ANALYSIS ===

--- SINGLE WORD OPERATIONS ---
[singleWord] Line 2844: singleWord: entry.displayWord || entry.word,
[singleWord] Line 3025: singleWord: entry.displayWord || entry.word,
[singleWord] Line 3604: const targetWord = nextWordEntry.singleWord || nextWordEntry.word;
[singleWord] Line 3674: const wordText = (entry.singleWord || entry.word || '').toLowerCase();
[singleWord] Line 4370: const retryTargetWord = retryWord.singleWord || retryWord.fullTerm || retryWord.word;
[singleWord] Line 4401: const targetWord = word.singleWord || word.fullTerm || word.term || word.word || word;
[singleWord] Line 4669: let word = getAdaptiveRandomWord(currentWordSoundsWord?.singleWord || currentWordSoundsWord);
[singleWord] Line 4679: const targetWord = word.singleWord || word.fullTerm || word.term || word.word || word;
[regenerate] Line 1456: onRegenerateWord, // NEW: Function to regenerate a specific word
[regenerate] Line 1457: onRegenerateAll,  // NEW: Function to regenerate all words
[regenerate] Line 1458: regeneratingIndex, // Index of word currently being regenerated
[regenerate] Line 1531: {/* Per-Word Regenerate Button */}
[regenerate] Line 1539: if (onRegenerateWord) {
[regenerate] Line 1540: onRegenerateWord(idx);
[regenerate] Line 1551: title="Regenerate this word"
[regenerate] Line 3896: const handleRegenerateWord = React.useCallback(async (index) => {
[regenerate] Line 3960: console.log("ðŸ”Š Auto-playing regenerated word:", targetWord);
[regenerate] Line 3975: // Handler to regenerate all words
[regenerate] Line 4202: // FIX: Only regenerate options when WORD changes, not on every effect run
[regenerate] Line 5699: onRegenerateWord={handleRegenerateWord}
[regenerate] Line 57400: {gameMode === 'wordsearch' ? t('common.regenerate') : t('glossary.word_search')}
[refresh] Line 3929: const refreshedWord = {
[refresh] Line 3947: updated[index] = refreshedWord;
[refresh] Line 3952: preloadedWordCache.current.set(targetWord.toLowerCase(), refreshedWord);
[refresh] Line 3953: console.log("âœ… Refreshed phoneme data for:", targetWord, refreshedWord);
[refresh] Line 4960: // But soundChips is derived/stabilized. We might need to force a refresh or update soundChips directly.
[refresh] Line 58327: {isGeneratingTermImage[idx] ? <RefreshCw size={10} c
[retry] Line 3204: // Fetch phoneme data for a word using AI (with automatic retry)
[retry] Line 3229: const fetchWordData = React.useCallback(async (word, retryCount = 0, isBackground = false) => {
[retry] Line 4367: const retryWord = getAdaptiveRandomWord();
[retry] Line 4368: if (retryWord) {
[retry] Line 4370: const retryTargetWord = retryWord.singleWord || retryWord.fullTerm || retryWord.word;
[retry] Line 4371: setCurrentWordSoundsWord(retryTargetWord);
[retry] Line 4372: setCurrentWordImage(retryWord.image);
[retry] Line 4373: setShowWordText(!retryWord.image);
[retry] Line 4374: fetchWordData(retryTargetWord);
[refetch] Line 3571: const prefetchNextWords = React.useCallback(async () => {
[refetch] Line 3576: const wordsNeeded = PREFETCH_BUFFER_SIZE - currentBufferSize;
[refetch] Line 3580: console.log(`ðŸš€ Prefetch starting: need ${wordsNeeded} words`);
[refetch] Line 3616: console.warn(`Prefetch failed for ${targetWord}`, e);
[refetch] Line 3632: }, [preloadedWords, isPrefetching, currentWordSoundsWord, wordSoundsActivity, fetchWordData, getDifficultyFilteredPo
[refetch] Line 3692: const prefetchPromises = wordsToPreload.map(async (wordEntry, i) => {
[refetch] Line 3698: console.log("âš¡ [Prefetch] using Glossary data for:", targetWord);
[refetch] Line 3855: // We rely on the useEffect at line ~3004 to start the activity and trigger prefetchNextWords().
[refetch] Line 4026: // Trigger prefetch when current word is loaded and stable
[refetch] Line 4030: const timer = setTimeout(() => prefetchNextWords(), 1000);
[refetch] Line 4033: }, [wordSoundsPhonemes, nextWordBuffer, isLoadingPhonemes, prefetchNextWords]);
[refetch] Line 4206: // SKIP if options were already pre-generated by fetchWordData or prefetchNextWords
[refetch] Line 4449: prefetchNextWords();
[refetch] Line 4456: }, [wordPool, currentWordSoundsWord, wordSoundsActivity, startActivity, isLoadingPhonemes, prefetchNextWords, showRe
[refetch] Line 4665: setTimeout(() => prefetchNextWords(), 100);
[refetch] Line 4691: setTimeout(() => prefetchNextWords(), 500);
[refetch] Line 4703: nextWordBuffer, preloadedWords, prefetchNextWords, generateSoundChips]); // Added dependencies
[reload] Line 1447: // Allows editing preloaded word data before starting activity
[reload] Line 1450: preloadedWords,
[reload] Line 1478: const word = preloadedWords[wordIdx];
[reload] Line 1485: const word = preloadedWords[wordIdx];
[reload] Line 1494: if (newIndex < 0 || newIndex >= preloadedWords.length) return;
[reload] Line 1496: const newList = [...preloadedWords];
[reload] Line 1509: <p className="text-sm opacity-80 mt-1">Review and edit preloaded words before starting â€¢ {preloadedW
[reload] Line 1514: {preloadedWords.length === 0 ? (
[reload] Line 1517: {isLoading ? <p className="animate-pulse">Generating new words... this may take a moment</p>
[reload] Line 1520: preloadedWords.map((word, idx) => (
[reload] Line 1567: disabled={idx === preloadedWords.length - 1}
[reload] Line 1568: className={`w-6 h-6 flex items-center justify-center rounded text-xs ${i
[reload] Line 1846: // Lifted state for preloaded words persistence
[reload] Line 1847: wsPreloadedWords = [],
[reload] Line 1848: setWsPreloadedWords
[reload] Line 1892: const preloadedWords = wsPreloadedWords || [];
[reload] Line 1893: const setPreloadedWords = setWsPreloadedWords || (() => {
[reload] Line 1894: console.warn("setWsPreloadedWords is not defined - updates won't persist");
[reload] Line 1899: const preloadedWordCache = React.useRef(new Map()); // Key: word, Value: preload data (persists across activity open
[reload] Line 3573: const currentBufferSize = preloadedWords.length;
[reload] Line 3582: const newPreloadedWords = [];
[reload] Line 3585: ...preloadedWords.map(w => w.targetWord?.toLowerCase())
[reload] Line 3613: newPreloadedWords.push({ targetWord, data });
[reload] Line 3623: if (newPreloadedWords.length > 0) {
[reload] Line 3624: setPreloadedWords(prev => [...prev, ...newPreloadedWords]);
[reload] Line 3632: }, [preloadedWords, isPrefetching, currentWordSoundsWord, wordSoundsActivity, fetchWordData, getDifficultyFilteredPo
[reload] Line 3634: // BULK PRELOAD: Fetch 15 words with phoneme data and TTS on modal open
[reload] Line 3635: // EAGER-START: Load first word immediately, start activity, preload rest in background
[reload] Line 3642: if (preloadedWords.length > 0) {
[reload] Line 3643: console.log("ðŸ›¡ï¸ Blocking preloadInitialBatch: words already loaded");
[reload] Line 3647: // SMART INCREMENTAL PRELOADING: Only preload words not already in cache
[reload] Line 3648: const alreadyCached = preloadedWordCache.current.size;
[reload] Line 3653: console.warn("Word pool empty, skipping preload");
[reload] Line 3661: // FIX: Increased preload count for better word coverage
[reload] Line 3662: const PRELOAD_COUNT = 10; // Load more words for Review Panel
[reload] Line 3663: const wordsToPreload = [];
[reload] Line 3671: if (wordsToPreload.length >= PRELOAD_COUNT) break;
[reload] Line 3675: if (preloadedWordCache.current.has(wordText)) {
[reload] Line 3682: wordsToPreload.push(entry);
[reload] Line 3686: const totalSteps = wordsToPreload.length * 2;
[reload] Line 3692: const prefetchPromises = wordsToPreload.map(async (wordEntry, i) => {
[reload] Line 3791: // Preload key sounds in parallel
[reload] Line 3805: // The existing code used `setPreloadedWords([...preloadedData])` incrementally.
[reload] Line 3831: setPreloadedWords(validResults);
[reload] Line 3834: // Populate cache with newly preloaded words
[reload] Line 3837: if (key) preloadedWordCache.current.set(key, w);
[reload] Line 3839: console.log(`ðŸ“¦ Cache now has ${preloadedWordCache.current.size} words`);
[reload] Line 3848: }, [isPreloading, preloadedWords.length, wordPool, callGemini, handleAudio, wordSoundsLanguage]);
[reload] Line 3857: if (wordPool && wordPool.length > 0 && preloadedWords.length === 0 && !isPreloading) {
[reload] Line 3861: }, [wordPool, preloadedWords.length, isPreloading, preloadInitialBatch]);
[reload] Line 3863: // NEW: Watch for preloaded words and show Review Panel when ready
[reload] Line 3867: if (preloadedWords.length > 0 && !showReviewPanel && !currentWordSoundsWord && !hasStartedFromReview.current) {
[reload] Line 3868: console.log("ðŸ“‹ Preloaded words ready! Showing Review Panel");
[reload] Line 3871: }, [preloadedWords.length, showReviewPanel, currentWordSoundsWord]);
[reload] Line 3873: // Handler to reorder preloaded words list
[reload] Line 3874: const handleReorderPreloadedWords = React.useCallback((newOrder) => {
[reload] Line 3875: setPreloadedWords(newOrder);
[reload] Line 3878: // Handler for editing preloaded word data in Review Panel
[reload] Line 3879: const handleUpdatePreloadedWord = React.useCallback((index, newData) => {
[reload] Line 3881: setPreloadedWords(prev => {
[reload] Line 3890: preloadedWordCache.current.set(wordKey, newData);
[reload] Line 3897: const existingWord = preloadedWords[index];
[reload] Line 3922: preloadedWordCache.current.delete(targetWord.toLowerCase());
[reload] Line 3928: console.log("ðŸ”„ [REGEN] Starting regeneration for index:", index, "Current words:", preloadedWords.map(w
[reload] Line 3944: setPreloadedWords(prev => {
[reload] Line 3945: console.log("ðŸ”„ [REGEN] Updating preloadedWords. Prev length:", prev.length);
[reload] Line 3952: preloadedWordCache.current.set(targetWord.toLowerCase(), refreshedWord);
[reload] Line 3973: }, [preloadedWords, fetchWordData, setPreloadedWords]);
[reload] Line 3997: // Clear current preloaded words and cache
[reload] Line 3998: setPreloadedWords([]);
[reload] Line 3999: preloadedWordCache.current.clear();
[reload] Line 4008: }, [wordPool, preloadInitialBatch]);
[reload] Line 4011: if (firstWordReady && preloadedWords.length > 0 && !currentWordSoundsWord && !isLoadingPhonemes) {
[reload] Line 4012: const firstWord = preloadedWords[0];
[reload] Line 4023: }, [firstWordReady, preloadedWords, currentWordSoundsWord, isLoadingPhonemes, showReviewPanel]);
[reload] Line 4409: const preloadedWord = preloadedWords.find(
[reload] Line 4414: if (preloadedWord && preloadedWord.phonemes) {
[reload] Line 4415: console.log("ðŸš€ Using preloaded data for:", targetWord);
[reload] Line 4416: setWordSoundsPhonemes(preloadedWord.phonemes);
[reload] Line 4423: }, [getAdaptiveRandomWord, fetchWordData, setWordSoundsActivity, setCurrentWordSoundsWord, setWordSoundsFeedback, wo
[reload] Line 4440: if (preloadedWords.length > 0 && !hasStartedFromReview.current) {
[reload] Line 4446: // Start preloading - Review Panel will appear when words are ready
[reload] Line 4447: console.log("Starting word preloading...");
[reload] Line 4456: }, [wordPool, currentWordSoundsWord, wordSoundsActivity, startActivity, isLoadingPhonemes, prefetchNextWords, showRe
[reload] Line 4600: if (preloadedWords && preloadedWords.length > 0) {
[reload] Line 4602: const bufferedWord = preloadedWords[0];
[reload] Line 4659: setPreloadedWords(prev => prev.slice(1));
[reload] Line 4703: nextWordBuffer, preloadedWords, prefetchNextWords, generateSoundChips]); // Added dependencies
[reload] Line 5696: preloadedWords={preloadedWords}
[reload] Line 5697: onUpdateWord={handleUpdatePreloadedWord}
[reload] Line 5698: onReorderWords={handleReorderPreloadedWords}
[reload] Line 5705: // Start with first word from preloaded list
[reload] Line 5706: const firstWord = preloadedWords[0];
[reload] Line 5799: {preloadedWords.length > 0 && (
[reload] Line 5803: title="Preview and edit preloaded words"
[reload] Line 25785: // Word Sounds Preloaded Words State - Lifted from modal for persistence
[reload] Line 25786: const [wsPreloadedWords, setWsPreloadedWords] = useState([]);
[reload] Line 28749: // Persist wsPreloadedWords to currently active glossary/word-sounds history item
[reload] Line 28751: if (!generatedContent || wsPreloadedWords.length === 0) return;
[reload] Line 28754: // Update the history item with preloaded words for JSON persistence
[reload] Line 28759: // Only update if wsPreloadedWords has changed
[reload] Line 28760: if (JSON.stringify(prev[idx].wsPreloadedWords) === JSON.stringify(wsPreloadedWords)) return prev;
[reload] Line 28763: updated[idx] = { ...updated[idx], wsPreloadedWords };
[reload] Line 28764: console.log("ðŸ’¾ Persisted preloaded words to history item:", wsPreloadedWords.length, "words");
[reload] Line 28767: }, [wsPreloadedWords, generatedContent]);
[reload] Line 38755: // Restore preloaded words if saved with the resource
[reload] Line 38756: if (item.wsPreloadedWords && Array.isArray(item.wsPreloadedWords)) {
[reload] Line 38757: console.log("ðŸ“¥ Restoring preloaded words from saved resource:", item.wsPreloadedWords.length);
[reload] Line 38758: setWsPreloadedWords(item.wsPreloadedWords);
[reload] Line 58028: wsPreloadedWords={wsPreloadedWords}
[reload] Line 58029: setWsPreloadedWords={setWsPreloadedWords}

--- WORD POOL/LIST MANAGEMENT ---
[wordPool] Line 2775: const wordPool = React.useMemo(() => {
[wordPool] Line 2840: if (!wordPool || wordPool.length === 0) return null;
[wordPool] Line 2841: const randomIndex = Math.floor(Math.random() * wordPool.length);
[wordPool] Line 2842: const entry = wordPool[randomIndex];
[wordPool] Line 2849: }, [wordPool]);
[wordPool] Line 2902: return wordPool.map(entry => ({
[wordPool] Line 2906: }, [wordPool, categorizeWordDifficulty]);
[wordPool] Line 2970: const easyPool = React.useMemo(() => wordPool ? wordPool.filter(w => categorizeWordDifficulty && categorizeWordDiffi
[wordPool] Line 2971: const mediumPool = React.useMemo(() => wordPool ? wordPool.filter(w => categorizeWordDifficulty && categorizeWordDif
[wordPool] Line 2972: const hardPool = React.useMemo(() => wordPool ? wordPool.filter(w => categorizeWordDifficulty && categorizeWordDiffi
[wordPool] Line 2977: if (!wordPool || wordPool.length === 0) return [];
[wordPool] Line 2982: let diffFiltered = wordPool;
[wordPool] Line 2987: else diffFiltered = wordPool.filter(w => categorizeWordDifficulty(w.word) === difficulty);
[wordPool] Line 2994: candidates = wordPool; // Use full pool if needed
[wordPool] Line 3040: }, [wordPool, wordSoundsHistory, categorizeWordDifficulty, isSequentialMode]);
[wordPool] Line 3264: const poolEntry = wordPool.find(p => p.word === word.toLowerCase() && p.phonemes && p.phonemes.length > 0);
[wordPool] Line 3652: if (!wordPool || wordPool.length === 0) {
[wordPool] Line 3669: const difficultyPool = [...wordPool].sort(() => Math.random() - 0.5);
[wordPool] Line 3848: }, [isPreloading, preloadedWords.length, wordPool, callGemini, handleAudio, wordSoundsLanguage]);
[wordPool] Line 3857: if (wordPool && wordPool.length > 0 && preloadedWords.length === 0 && !isPreloading) {
[wordPool] Line 3861: }, [wordPool, preloadedWords.length, isPreloading, preloadInitialBatch]);
[wordPool] Line 3990: if (!wordPool || wordPool.length === 0) {
[wordPool] Line 4008: }, [wordPool, preloadInitialBatch]);
[wordPool] Line 4341: if (!wordPool || wordPool.length === 0) {
[wordPool] Line 4363: if (wordPool && wordPool.length > 0 && recursionDepth === 0 && !isSequentialMode) {
[wordPool] Line 4423: }, [getAdaptiveRandomWord, fetchWordData, setWordSoundsActivity, setCurrentWordSoundsWord, setWordSoundsFeedback, wo
[wordPool] Line 4435: if (wordPool && wordPool.length > 0 && !currentWordSoundsWord && !isLoadingPhonemes) {
[wordPool] Line 4456: }, [wordPool, currentWordSoundsWord, wordSoundsActivity, startActivity, isLoadingPhonemes, prefetchNextWords, showRe
[wordPool] Line 4672: if (!word && wordPool && wordPool.length > 0) {
[wordList] Line 2953: setSessionWordLists(prev => ({...prev, [activityId]: remaining}));
[wordList] Line 2965: const [sessionWordLists, setSessionWordLists] = React.useState({});
[wordList] Line 3037: setSessionWordLists(prev => ({...prev, [activityId]: queue}));
[setWords] Line 1787: setWordSoundsActivity,
[setWords] Line 1789: setWordSoundsScore,
[setWords] Line 1793: setWordSoundsPhonemes,
[setWords] Line 1795: setWordSoundsLanguage,
[setWords] Line 1797: setWordSoundsFeedback,
[setWords] Line 1799: setWordSoundsHistory,
[setWords] Line 1803: setWordSoundsFamilies,
[setWords] Line 1805: setWordSoundsAudioLibrary,
[setWords] Line 1816: setWordSoundsDifficulty,
[setWords] Line 1821: setWordSoundsAccuracyHistory,
[setWords] Line 1823: setWordSoundsTtsSpeed,
[setWords] Line 1826: setWordSoundsStreak,
[setWords] Line 1828: setWordSoundsSessionGoal,
[setWords] Line 1830: setWordSoundsSessionProgress,
[setWords] Line 1832: setWordSoundsBadges,
[setWords] Line 1834: setWordSoundsLevel,
[setWords] Line 1839: setWordSoundsDailyProgress,
[setWords] Line 1841: setWordSoundsConfusionPatterns,
[setWords] Line 3110: if (!setWordSoundsConfusionPatterns) return;
[setWords] Line 3112: setWordSoundsConfusionPatterns(prev => {
[setWords] Line 3118: }, [setWordSoundsConfusionPatterns]);
[setWords] Line 3122: if (!setWordSoundsDailyProgress) return;
[setWords] Line 3125: setWordSoundsDailyProgress(prev => {
[setWords] Line 3136: }, [setWordSoundsDailyProgress]);
[setWords] Line 3140: if (!setWordSoundsBadges) return;
[setWords] Line 3165: setWordSoundsBadges(prev => [...prev, ...newBadges]);
[setWords] Line 3170: }, [wordSoundsHistory, wordSoundsBadges, setWordSoundsBadges]);
[setWords] Line 3219: setWordSoundsPhonemes(data);
[setWords] Line 3492: setWordSoundsPhonemes(prev => ({ ...prev, blendingDistractors: distractors }));
[setWords] Line 4313: setWordSoundsActivity(activityId);
[setWords] Line 4314: setWordSoundsFeedback?.(null);
[setWords] Line 4326: if (setWordSoundsSessionProgress) setWordSoundsSessionProgress(0);
[setWords] Line 4343: setWordSoundsFeedback?.({
[setWords] Line 4354: setWordSoundsFeedback?.({
[setWords] Line 4386: setWordSoundsFeedback?.({
[setWords] Line 4416: setWordSoundsPhonemes(preloadedWord.phonemes);
[setWords] Line 4423: }, [getAdaptiveRandomWord, fetchWordData, setWordSoundsActivity, setCurrentWordSoundsWord, setWordSoundsFeedback, wo
[setWords] Line 4470: setWordSoundsFeedback?.({
[setWords] Line 4475: setTimeout(() => setWordSoundsFeedback?.(null), 1500);
[setWords] Line 4497: setWordSoundsScore(prev => ({
[setWords] Line 4503: if (setWordSoundsStreak) setWordSoundsStreak(newStreak);
[setWords] Line 4519: setWordSoundsHistory(prev => [...prev, {
[setWords] Line 4534: setWordSoundsFeedback({
[setWords] Line 4542: setWordSoundsFeedback({
[setWords] Line 4547: setTimeout(() => setWordSoundsActivity('orthography'), 2000);
[setWords] Line 4562: if (isCorrect && setWordSoundsSessionProgress) {
[setWords] Line 4563: setWordSoundsSessionProgress(prev => {
[setWords] Line 4568: setWordSoundsLevel && setWordSoundsLevel(l => l + 1); // Increment level
[setWords] Line 4569: setWordSoundsFeedback?.({
[setWords] Line 4587: setWordSoundsFeedback?.({
[setWords] Line 4661: setWordSoundsFeedback?.(null);
[setWords] Line 4687: setWordSoundsFeedback?.(null);
[setWords] Line 4700: onScoreUpdate, setWordSoundsScore, setWordSoundsHistory, setWordSoundsFeedback,
[setWords] Line 4702: updatePhonemeMastery, trackConfusion, updateDailyProgress, checkAndAwardBadges, setWordSoundsStreak,
[setWords] Line 4943: setWordSoundsPhonemes(newPhonemes);
[setWords] Line 4951: setWordSoundsPhonemes(prev => ({ ...prev, graphemes: newGraphemes }));
[setWords] Line 4957: setWordSoundsPhonemes(updated);
[setWords] Line 5660: setWordSoundsScore({ correct: 0, total: 0 });
[setWords] Line 5661: setWordSoundsSessionProgress?.(0);
[setWords] Line 5671: setWordSoundsActivity(null); // Return to activity picker
[setWords] Line 5709: setWordSoundsPhonemes(firstWord);
[setWords] Line 5852: {availableLanguages.length > 1 && setWordSoundsLanguage && (
[setWords] Line 5859: onChange={(e) => setWordSoundsLanguage(e.target.value)}
[setWords] Line 5875: {setWordSoundsDifficulty && (
[setWords] Line 5878: onChange={(e) => setWordSoundsDifficulty(e.target.value)}
[setWords] Line 24042: const [words, setWords] = React.useState([]);
[setWords] Line 24053: setWords(w);
[setWords] Line 25680: const [wordSoundsCustomTerms, setWordSoundsCustomTerms] = React.useState([]); // Custom Word List for Dedicated Gene
[setWords] Line 25681: const [wordSoundsOracleData, setWordSoundsOracleData] = React.useState(null); // Persistence Cache for Oracle Data
[setWords] Line 25775: const [wordSoundsHistory, setWordSoundsHistory] = useState(() => {
[setWords] Line 25790: const [wordSoundsDifficulty, setWordSoundsDifficulty] = useState('auto'); // 'easy', 'medium', 'hard', 'auto'
[setWords] Line 25791: const [wordSoundsAccuracyHistory, setWordSoundsAccuracyHistory] = useState([]); // Last 10 answers for adaptive diffic
[setWords] Line 25792: const [wordSoundsStreak, setWordSoundsStreak] = useState(0);
[setWords] Line 25793: const [wordSoundsSessionGoal, setWordSoundsSessionGoal] = useState(10);
[setWords] Line 25794: const [wordSoundsSessionProgress, setWordSoundsSessionProgress] = useState(0);
[setWords] Line 25795: const [wordSoundsBadges, setWordSoundsBadges] = useState(() => {
[setWords] Line 25813: const [wordSoundsDailyProgress, setWordSoundsDailyProgress] = useState(() => {
[setWords] Line 25830: const [wordSoundsConfusionPatterns, setWordSoundsConfusionPatterns] = useState(() => {
[setWords] Line 25841: const [wordSoundsFamilies, setWordSoundsFamilies] = useState({}); // { targetWord: { rhymes: [], minimalPairs: [] } }
[setWords] Line 25842: const [wordSoundsAudioLibrary, setWordSoundsAudioLibrary] = useState({}); // { text: base64String }
[setWords] Line 25844: const [wordSoundsTtsSpeed, setWordSoundsTtsSpeed] = useState(1.0);
[setWords] Line 26252: const [wordSoundsActivity, setWordSoundsActivity] = useState('counting'); // 'counting' | 'isolation' | 'blending' | '
[setWords] Line 26253: const [wordSoundsScore, setWordSoundsScore] = useState({ correct: 0, total: 0, streak: 0 });
[setWords] Line 26255: const [wordSoundsPhonemes, setWordSoundsPhonemes] = useState(null);
[setWords] Line 26256: const [wordSoundsLanguage, setWordSoundsLanguage] = useState('en');
[setWords] Line 26257: const [wordSoundsFeedback, setWordSoundsFeedback] = useState(null); // { type: 'correct'|'incorrect', message: '' }
[setWords] Line 26512: const [wordSearchLang, setWordSearchLang] = useState('English');
[setWords] Line 31729: setGeneratedContent(newItem); setWordSoundsCustomTerms(generatedTerms);
[setWords] Line 31747: setWordSoundsCustomTerms(derivedTerms);
[setWords] Line 38690: if (rawData.wordSoundsState.history) setWordSoundsHistory(rawData.wordSoundsState.history);
[setWords] Line 38691: if (rawData.wordSoundsState.families) setWordSoundsFamilies(rawData.wordSoundsState.families);
[setWords] Line 38692: if (rawData.wordSoundsState.audioLibrary) setWordSoundsAudioLibrary(rawData.wordSoundsState.aud
[setWords] Line 38693: if (rawData.wordSoundsState.badges) setWordSoundsBadges(rawData.wordSoundsState.badges);
[setWords] Line 38695: if (rawData.wordSoundsState.dailyProgress) setWordSoundsDailyProgress(rawData.wordSoundsState.d
[setWords] Line 38696: if (rawData.wordSoundsState.confusionPatterns) setWordSoundsConfusionPatterns(rawData.wordSound
[setWords] Line 38813: setGeneratedContent(newItem); setWordSoundsCustomTerms(generatedTerms);
[setWords] Line 50345: setGeneratedContent(newItem); setWordSoundsCustomTerms(generatedTerms);
[setWords] Line 57378: setWordSearchLang(e.target.value);
[setWords] Line 58031: setWordSoundsActivity={setWordSoundsActivity}
[setWords] Line 58033: setWordSoundsScore={setWordSoundsScore}
[setWords] Line 58037: setWordSoundsPhonemes={setWordSoundsPhonemes}
[setWords] Line 58039: setWordSoundsLanguage={setWordSoundsLanguage}
[setWords] Line 58041: setWordSoundsFeedback={setWordSoundsFeedback}
[setWords] Line 58043: setWordSoundsHistory={setWordSoundsHistory}
[setWords] Line 58052: setWordSoundsDifficulty={setWordSoundsDifficulty}
[setWords] Line 58054: setWordSoundsAccuracyHistory={setWordSoundsAccuracyHistory}
[setWords] Line 58056: setWordSoundsTtsSpeed={setWordSoundsTtsSpeed}
[setWords] Line 58059: setWordSoundsStreak={setWordSoundsStreak}
[setWords] Line 58061: setWordSoundsSessionGoal={setWordSoundsSessionGoal}
[setWords] Line 58063: setWordSoundsSessionProgress={setWordSoundsSessionProgress}
[setWords] Line 58065: setWordSoundsBadges={setWordSoundsBadges}
[setWords] Line 58070: setWordSoundsDailyProgress={setWordSoundsDailyProgress}
[setWords] Line 58072: setWordSoundsConfusionPatterns={setWordSoundsConfusionPatterns}

--- PHONEME/WORD GENERATION API CALLS ---
[callGemini] Line 990: const WordSoundsGenerator = ({ glossaryTerms, onStartGame, onClose, callGemini, callImagen, gradeLevel, t: tProp })
[callGemini] Line 1091: const result = await callGemini(prompt, false);
[callGemini] Line 1124: const result = await callGemini(prompt, true);
[callGemini] Line 1810: callGemini,
[callGemini] Line 3323: const result = await callGemini(prompt, true);
[callGemini] Line 3445: }, [wordSoundsLanguage, callGemini, handleAudio]);
[callGemini] Line 3487: const repairRes = await callGemini(repairPrompt, true);
[callGemini] Line 3515: }, [wordSoundsActivity, wordSoundsPhonemes, currentWordSoundsWord, callGemini, blendingOptions]);
[callGemini] Line 3734: const response = await callGemini(prompt, { temperature: 0.1 });
[callGemini] Line 3848: }, [isPreloading, preloadedWords.length, wordPool, callGemini, handleAudio, wordSoundsLanguage]);
[callGemini] Line 22974: const QuickStartWizard = ({ isOpen, onClose, onComplete, onUpload, onLookupStandards, onCallGemini, addToast, isParentMo
[callGemini] Line 23117: const content = await fetchAndCleanUrl(url, onCallGemini, addToast);
[callGemini] Line 23136: const result = await onCallGemini(prompt, false, true);
[callGemini] Line 25324: const result = await callGemini(prompt, false, true);
[callGemini] Line 25609: const result = await callGemini(prompt, true);
[callGemini] Line 29425: const result = await callGemini(prompt, true);
[callGemini] Line 29434: const repairResult = await callGemini(repairPrompt, true);
[callGemini] Line 29500: const result = await callGemini(prompt, true);
[callGemini] Line 31846: const result = await callGemini(prompt, true);
[callGemini] Line 31919: const newProblem = await callGemini(prompt);
[callGemini] Line 33136: const callGemini = async (prompt, jsonMode = false, useSearch = false, temperature = null) => {
[callGemini] Line 33190: return await callGemini(repairPrompt, true, false, 0.1);
[callGemini] Line 33219: console.warn("Gemini Model Refusal caught in callGemini (suppressed crash):", err.message);
[callGemini] Line 33252: const fixedString = await callGemini(repairPrompt, true);
[callGemini] Line 33329: const result = await callGemini(prompt, item.type !== 'simplified');
[callGemini] Line 33492: const response = await callGemini(prompt, true);
[callGemini] Line 33545: return await callGemini(prompt);
[callGemini] Line 33553: const resultRaw = await callGemini(intentPrompt, true);
[callGemini] Line 33663: const callGeminiImageEdit = async (prompt, base64Image, width = 800, qual = 0.9) => {
[callGemini] Line 33694: const callGeminiVision = async (prompt, base64Data, mimeType) => {
[callGemini] Line 33984: const refinedUrl = await callGeminiImageEdit(refinePrompt, rawBase64, 400, 0.9);
[callGemini] Line 34016: imageUrl = await callGeminiImageEdit(editPrompt, rawBase64);
[callGemini] Line 34314: const result = await callGemini(searchPrompt, false, true);
[callGemini] Line 34374: const content = await fetchAndCleanUrl(targetUrl, callGemini, addToast);
[callGemini] Line 34469: const text = await callGeminiVision(prompt, base64String, mimeType);
[callGemini] Line 34523: const result = await callGemini(prompt);
[callGemini] Line 34599: const result = await callGemini(verificationPrompt, false, true);
[callGemini] Line 34705: const researchResult = await callGemini(researchPrompt, false, true);
[callGemini] Line 34741: const outlineResult = await callGemini(outlinePrompt, true);
[callGemini] Line 34803: result = await callGemini(sectionPrompt, false, effIncludeCitations);
[callGemini] Line 34812: result = await callGemini(sectionPrompt, false, false);
[callGemini] Line 34949: const outlineResult = await callGemini(outlinePrompt, false, false, 1.6);
[callGemini] Line 35091: result = await callGemini(prompt, shouldUseJsonMode, useSearchForThisCall, creativeTemperature);
[callGemini] Line 35100: result = await callGemini(prompt, shouldUseJsonMode, false, creativeTemperature);
[callGemini] Line 35134: callGemini(cleanupPrompt),
[callGemini] Line 35387: const jsonStr = await callGemini(prompt, true);
[callGemini] Line 35444: const result = await callGemini(prompt);
[callGemini] Line 35488: const result = await callGemini(prompt);
[callGemini] Line 35518: const result = await callGemini(prompt, true);
[callGemini] Line 35622: const result = await callGemini(prompt);
[callGemini] Line 39163: const result = await callGemini(prompt, true);
[callGemini] Line 39235: const guide = await callGemini(prompt);
[callGemini] Line 39284: const result = await callGemini(prompt, true);
[callGemini] Line 39413: const hint = await callGemini(prompt);
[callGemini] Line 39452: const result = await callGemini(prompt);
[callGemini] Line 39656: const refinedUrl = await callGeminiImageEdit(editPrompt, rawBase64, targetWidth, targetQual);
[callGemini] Line 39720: const result = await callGemini(prompt);
[callGemini] Line 40227: const result = await callGemini(prompt);
[callGemini] Line 40494: const result = await callGemini(prompt, true);
[callGemini] Line 41163: const result = await callGemini(prompt, true);
[callGemini] Line 41468: const result = await callGemini(prompt, true);
[callGemini] Line 41662: const newImageBase64 = await callGeminiImageEdit(refinementPrompt, rawBase64);
[callGemini] Line 41695: const newImageBase64 = await callGeminiImageEdit(refinementPrompt, currentImageBase64);
[callGemini] Line 41746: const summary = await callGemini(prompt);
[callGemini] Line 41875: const guide = await callGemini(prompt);
[callGemini] Line 42161: const result = await callGemini(prompt);
[callGemini] Line 42222: const responseText = await callGemini(fullPrompt);
[callGemini] Line 42370: const configResult = await callGemini(configPrompt, true);
[callGemini] Line 43158: const result = await callGemini(finalPrompt);
[callGemini] Line 43295: const result = await callGemini(prompt, false, true);
[callGemini] Line 43376: const newImageUrl = await callGeminiImageEdit(editPrompt, currentBase64, 400, 0.85);
[callGemini] Line 43514: const newImageUrl = await callGeminiImageEdit(editPrompt, currentBase64, 400, 0.85);
[callGemini] Line 43559: const result = await callGemini(prompt, true);
[callGemini] Line 43607: const result = await callGemini(prompt, true);
[callGemini] Line 43635: const result = await callGemini(prompt, true);
[callGemini] Line 43855: const result = await callGemini(prompt);
[callGemini] Line 43928: const resultRaw = await callGemini(prompt, true);
[callGemini] Line 44109: const resultRaw = await callGemini(prompt, true);
[callGemini] Line 44290: const result = await callGemini(prompt);
[callGemini] Line 44380: const result = await callGemini(prompt, true);
[callGemini] Line 44487: const result = await callGemini(prompt, true);
[callGemini] Line 44555: const summary = await callGemini(prompt);
[callGemini] Line 44611: const result = await callGemini(prompt, true);
[callGemini] Line 44707: const result = await callGemini(prompt, true);
[callGemini] Line 44983: const response = await callGemini(escapeRoomPrompt, true);
[callGemini] Line 45092: const response = await callGemini(escapeRoomPrompt, true);
[callGemini] Line 45832: const result = await callGemini(prompt, true);
[callGemini] Line 45864: imageUrl = await callGeminiImageEdit(editPrompt, rawBase64);
[callGemini] Line 46132: let targetResult = await callGemini(chunkTargetPrompt);
[callGemini] Line 46146: let transResult = await callGemini(chunkTransPrompt);
[callGemini] Line 46217: content = await callGemini(prompt);
[callGemini] Line 46278: const result = await callGemini(prompt, true);
[callGemini] Line 46308: const repairResult = await callGemini(repairPrompt, true);
[callGemini] Line 46336: const result = await callGemini(promptGenPrompt, true);
[callGemini] Line 46381: const refinedImage = await callGeminiImageEdit(refinePrompt, rawBase64, targetWidth, targetQual);
[callGemini] Line 46448: const result = await callGemini(prompt, true);
[callGemini] Line 46501: const factCheckResult = await callGemini(checkPrompt);
[callGemini] Line 46604: const result = await callGemini(prompt, true, false);
[callGemini] Line 46653: const repairResult = await callGemini(repairPrompt, true);
[callGemini] Line 46776: const result = await callGemini(prompt, true);
[callGemini] Line 46825: const result = await callGemini(prompt, true);
[callGemini] Line 46876: const result = await callGemini(prompt, true);
[callGemini] Line 47021: const result = await callGemini(prompt, true);
[callGemini] Line 47101: const result = await callGemini(prompt, true);
[callGemini] Line 47193: const result = await callGemini(prompt, true);
[callGemini] Line 47261: const result = await callGemini(prompt, true);
[callGemini] Line 47317: const result = await callGemini(prompt, true);
[callGemini] Line 47361: const result = await callGemini(prompt, true);
[callGemini] Line 47441: const result = await callGemini(prompt, true);
[callGemini] Line 47497: const result = await callGemini(prompt, false, true);
[callGemini] Line 47848: const partResult = await callGemini(fixPrompt);
[callGemini] Line 47982: const result = await callGemini(prompt);
[callGemini] Line 49104: const result = await callGemini(prompt, true);
[callGemini] Line 49118: imageUrl = await callGeminiImageEdit(editPrompt, rawBase64);
[callGemini] Line 49181: const result = await callGemini(prompt, true);
[callGemini] Line 49192: imageUrl = await callGeminiImageEdit(editPrompt, rawBase64);
[callGemini] Line 49279: imageUrl = await callGeminiImageEdit(editPrompt, rawBase64);
[callGemini] Line 49323: const result = await callGemini(prompt, true);
[callGemini] Line 49352: }, [gradeLevel, callGemini, callImagen]);
[callGemini] Line 49529: const result1 = await callGemini(prompt1, true);
[callGemini] Line 49561: const result2 = await callGemini(prompt2, true);
[callGemini] Line 49625: const result = await callGemini(prompt, false, true);
[callGemini] Line 49697: const result = await callGemini(prompt, true);
[callGemini] Line 49745: const newText = await callGemini(prompt);
[callGemini] Line 49808: const result = await callGemini(prompt);
[callGemini] Line 49920: return await callGemini(prompt);
[callGemini] Line 49951: const gateResultRaw = await callGemini(gatePrompt, true);
[callGemini] Line 49997: const gradingRaw = await callGemini(gradingPrompt, true);
[callGemini] Line 50126: const rubricText = await callGemini(prompt);
[callGemini] Line 50190: const result = await callGemini(prompt, true);
[callGemini] Line 50307: const result = await callGemini(prompt, jsonMode);
[callGemini] Line 57132: }) || await callGemini(fixPrompt, false, false, null);
[callGemini] Line 58046: callGemini={callGemini}
[callGemini] Line 60140: onRefineImage={callGeminiImageEdit}
[callGemini] Line 64463: callGemini={callGemini}
[callGemini] Line 65696: return await callGeminiVision(prompt, base64, mimeType);
[callGemini] Line 65738: onCallGemini={callGemini}

--- LOADING/PENDING STATES ---
[isLoading] Line 1517: {isLoading ? <p className="animate-pulse">Generating new words... this may take a moment</p>
[isLoading] Line 1851: const [isLoadingPhonemes, setIsLoadingPhonemes] = React.useState(false);
[isLoading] Line 3220: setIsLoadingPhonemes(false);
[isLoading] Line 3275: if (!isBackground) setIsLoadingPhonemes(true);
[isLoading] Line 4011: if (firstWordReady && preloadedWords.length > 0 && !currentWordSoundsWord && !isLoadingPhonemes) {
[isLoading] Line 4023: }, [firstWordReady, preloadedWords, currentWordSoundsWord, isLoadingPhonemes, showReviewPanel]);
[isLoading] Line 4028: if (wordSoundsPhonemes && !nextWordBuffer && !isLoadingPhonemes) {
[isLoading] Line 4033: }, [wordSoundsPhonemes, nextWordBuffer, isLoadingPhonemes, prefetchNextWords]);
[isLoading] Line 4272: if (currentWordSoundsWord && !isLoadingPhonemes) {
[isLoading] Line 4309: }, [currentWordSoundsWord, isLoadingPhonemes, handleAudio, wordSoundsActivity, rhymeOptions, playBlending]);
[isLoading] Line 4417: setIsLoadingPhonemes(false);
[isLoading] Line 4435: if (wordPool && wordPool.length > 0 && !currentWordSoundsWord && !isLoadingPhonemes) {
[isLoading] Line 4456: }, [wordPool, currentWordSoundsWord, wordSoundsActivity, startActivity, isLoadingPhonemes, prefetchNextWords, showRe
[isLoading] Line 5074: if (isLoadingPhonemes) {
[isLoading] Line 5701: regeneratingIndex={regeneratingIndex} isLoading={isLoadingPhonemes}
[isLoading] Line 5710: setIsLoadingPhonemes(false);
[isProcessing] Line 1371: {isProcessing ? t('status.generating', 'Generating...') : t('word_sounds.start', 'St
[isGenerating] Line 58327: {isGeneratingTermImage[idx] ? <RefreshCw size={10} c

--- WORDSOUNDSMODAL CORE LOGIC ---
Line 1782: const WordSoundsModal = ({
Line 2831: console.warn("âš ï¸ WordSoundsModal: glossaryTerms is empty or undefined");
Line 2834: console.log("âœ… WordSoundsModal: availableLanguages", result);
Line 26258: const wordSoundsModalRef = useRef(null);
Line 31732: // Set isWordSoundsMode to true so WordSoundsModal renders
Line 58024: <WordSoundsModal

--- REPLACE/SWAP WORD FUNCTIONALITY ---
[removeWord] Line 26666: const [autoRemoveWords, setAutoRemoveWords] = useState(true);
[removeWord] Line 45844: addToast(autoRemoveWords ? t('status_steps.refining_icons') : t('status_steps.generating_icons'), "info");
[removeWord] Line 45846: setGenerationStep(autoRemoveWords ? t('status_steps.refining_icons') : t('status_steps.generating_icons'));
[removeWord] Line 45860: if (autoRemoveWords) {
[removeWord] Line 49113: if (autoRemoveWords) {
[removeWord] Line 49187: if (autoRemoveWords) {
[removeWord] Line 49274: if (autoRemoveWords) {
[removeWord] Line 54247: checked={autoRemoveWords}
[removeWord] Line 54248: onChange={(e) => setAutoRemoveWords(e.target.checked)}
[updateWord] Line 1451: onUpdateWord,
[updateWord] Line 1480: onUpdateWord(wordIdx, { ...word, phonemes: newPhonemes });
[updateWord] Line 1487: onUpdateWord(wordIdx, { ...word, phonemes: newPhonemes });
[updateWord] Line 1584: onChange={(e) => onUpdateWord(idx, { ...word, difficulty: e.target.value })}
[updateWord] Line 1669: onChange={(e) => onUpdateWord(idx, { ...word, rhymeWord: e.targe
[updateWord] Line 1680: onUpdateWord(idx, { ...word, rhymeDistractors: newDist }
[updateWord] Line 1705: onUpdateWord(idx, { ...word, blendingDistractors: newDis
[updateWord] Line 1721: onChange={(e) => onUpdateWord(idx, { ...word, firstSound: e.targ
[updateWord] Line 1729: onChange={(e) => onUpdateWord(idx, { ...word, lastSound: e.targe
[updateWord] Line 5697: onUpdateWord={handleUpdatePreloadedWord}

--- SET CURRENT WORD HANDLERS ---
Line 1791: setCurrentWordSoundsWord,
Line 4371: setCurrentWordSoundsWord(retryTargetWord);
Line 4402: setCurrentWordSoundsWord(targetWord);
Line 4423: }, [getAdaptiveRandomWord, fetchWordData, setWordSoundsActivity, setCurrentWordSoundsWord, setWordSoundsFeedback, wo
Line 4605: setCurrentWordSoundsWord(targetWord);
Line 4680: setCurrentWordSoundsWord(targetWord);
Line 4701: getAdaptiveRandomWord, setCurrentWordSoundsWord, fetchWordData, ts, getEffectiveDifficulty,
Line 5708: setCurrentWordSoundsWord(firstWord.targetWord || firstWord.word);
Line 26254: const [currentWordSoundsWord, setCurrentWordSoundsWord] = useState(null);
Line 58035: setCurrentWordSoundsWord={setCurrentWordSoundsWord}
Line 1793: setWordSoundsPhonemes,
Line 3219: setWordSoundsPhonemes(data);
Line 3492: setWordSoundsPhonemes(prev => ({ ...prev, blendingDistractors: distractors }));
Line 4416: setWordSoundsPhonemes(preloadedWord.phonemes);
Line 4943: setWordSoundsPhonemes(newPhonemes);
Line 4951: setWordSoundsPhonemes(prev => ({ ...prev, graphemes: newGraphemes }));
Line 4957: setWordSoundsPhonemes(updated);
Line 5709: setWordSoundsPhonemes(firstWord);
Line 26255: const [wordSoundsPhonemes, setWordSoundsPhonemes] = useState(null);
Line 58037: setWordSoundsPhonemes={setWordSoundsPhonemes}
Line 1790: currentWordSoundsWord,
Line 3475: const targetToCheck = currentWordSoundsWord || wordSoundsPhonemes?.word;
Line 3486: const repairPrompt = `List 3 similar-sounding words (distractors) for "${currentWordSoundsWord}
Line 3502: const currentWord = currentWordSoundsWord || wordSoundsPhonemes?.word;
Line 3515: }, [wordSoundsActivity, wordSoundsPhonemes, currentWordSoundsWord, callGemini, blendingOptions]);
Line 3584: currentWordSoundsWord?.toLowerCase(),
Line 3632: }, [preloadedWords, isPrefetching, currentWordSoundsWord, wordSoundsActivity, fetchWordData, getDifficultyFilteredPo
Line 3867: if (preloadedWords.length > 0 && !showReviewPanel && !currentWordSoundsWord && !hasStartedFromReview.current) {
Line 3871: }, [preloadedWords.length, showReviewPanel, currentWordSoundsWord]);
Line 4011: if (firstWordReady && preloadedWords.length > 0 && !currentWordSoundsWord && !isLoadingPhonemes) {
Line 4023: }, [firstWordReady, preloadedWords, currentWordSoundsWord, isLoadingPhonemes, showReviewPanel]);
Line 4101: console.log("ðŸ”§ Initializing Elkonin boxes:", effectiveCount, "for", currentWordSoundsWord);
Line 4109: const targetWord = currentWordSoundsWord || wordSoundsPhonemes?.word;
Line 4128: const currentWord = currentWordSoundsWord || wordSoundsPhonemes?.word;
Line 4170: : generateNearRhymes(currentWordSoundsWord || 'cat');
Line 4181: const word = currentWordSoundsWord || '';
Line 4188: }, [wordSoundsPhonemes, wordSoundsActivity, currentWordSoundsWord, generateSoundChips]);
Line 4203: const currentWord = wordSoundsPhonemes?.word || currentWordSoundsWord;
Line 4239: const fallbackSound = (currentWordSoundsWord || '')[0]?.toLowerCase() || 'a';
Line 4244: word: currentWordSoundsWord, // FIX: Add word property to pass data integrity check
Line 4261: }, [wordSoundsActivity, wordSoundsPhonemes, isolationState, handleAudio, currentWordSoundsWord]); // Added isolation
Line 4272: if (currentWordSoundsWord && !isLoadingPhonemes) {
Line 4275: const playKey = `${currentWordSoundsWord}-${wordSoundsActivity}`;
Line 4289: await handleAudio(currentWordSoundsWord);
Line 4309: }, [currentWordSoundsWord, isLoadingPhonemes, handleAudio, wordSoundsActivity, rhymeOptions, playBlending]);
Line 4435: if (wordPool && wordPool.length > 0 && !currentWordSoundsWord && !isLoadingPhonemes) {
Line 4456: }, [wordPool, currentWordSoundsWord, wordSoundsActivity, startActivity, isLoadingPhonemes, prefetchNextWords, showRe
Line 4522: word: currentWordSoundsWord,
Line 4669: let word = getAdaptiveRandomWord(currentWordSoundsWord?.singleWord || currentWordSoundsWord);
Line 4699: }, [wordSoundsScore, wordSoundsActivity, currentWordSoundsWord, wordSoundsPhonemes,
Line 4713: let expected = currentWordSoundsWord;
Line 4731: }, [useMicInput, isListening, userAnswer, wordSoundsActivity, currentWordSoundsWord, wordSoundsPhonemes, checkAnswer
Line 4772: let expected = currentWordSoundsWord;
Line 4787: }, [wordSoundsLanguage, isListening, currentWordSoundsWord, wordSoundsActivity, wordSoundsPhonemes, checkAnswer, add
Line 4915: const family = newPhonemes.wordFamily || (currentWordSoundsWord?.length > 2 ? currentWordSoundsWord.slice(1
Line 4919: currentWordSoundsWord,
Line 5003: onClick={() => wordSoundsActivity === 'blending' ? playBlending() : handleAudio(currentWordSound
Line 5015: onClick={() => wordSoundsActivity === 'blending' ? playBlending() : handleAudio(currentWordSoundsWor
Line 5021: {currentWordSoundsWord}
Line 5100: if (!isolationState || (isoWord && isoWord.toLowerCase() !== currentWordSoundsWord?.toLowerCase())) {
Line 5108: key={currentWordSoundsWord}
Line 5111: word: currentWordSoundsWord,
Line 5344: const isCorrect = word?.toLowerCase() === currentWordSoundsW
Line 5371: const correctWord = currentWordSoundsWord;
Line 5402: word: currentWordSoundsWord,
Line 5404: correct: currentWordSoundsWord
Line 5408: onCheckAnswer={(ans) => checkAnswer(ans, currentWordSoundsWord)}
Line 5418: key={currentWordSoundsWord}
Line 5420: word: currentWordSoundsWord,
Line 5422: graphemes: wordSoundsPhonemes?.graphemes || currentWordSoundsWord?.split('') || []
Line 5438: rhymes with "{currentWordSoundsWord}"
Line 5465: word: currentWordSoundsWord,
Line 5492: const family = wordSoundsPhonemes?.wordFamily || (currentWordSoundsWord?.length > 2 ? currentWordSoundsW
Line 5496: currentWordSoundsWord,
Line 5511: key={currentWordSoundsWord}
Line 26254: const [currentWordSoundsWord, setCurrentWordSoundsWord] = useState(null);
Line 58034: currentWordSoundsWord={currentWordSoundsWord}

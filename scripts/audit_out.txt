=== setCurrentWordSoundsWord calls ===
L7986: setCurrentWordSoundsWord(retryTargetWord);
L8031: setCurrentWordSoundsWord(targetWord);
L8151: setCurrentWordSoundsWord(w);
L8907: setCurrentWordSoundsWord(targetWord);
L8998: setCurrentWordSoundsWord(targetWord);
L9058: setCurrentWordSoundsWord(target);
L11364: setCurrentWordSoundsWord(firstWord.targetWord || firstWord.word);
L47210: setCurrentWordSoundsWord(null); // FIX: Reset to allow review panel to show
L65837: <ErrorBoundary fallbackMessage="Word Sounds encountered an error." onError={(error) => console.error("ErrorBoundary CAUGHT:", error?.message || error)} onRetry={() => { setWordSoun
L65842: onClose={() => { setIsWordSoundsMode(false); setCurrentWordSoundsWord(null); setWordSoundsPhonemes(null); setWordSoundsFeedback(null); setWordSoundsActivity(null); setWordSoundsAut
L65843: onBackToSetup={() => { setIsWordSoundsMode(false); setCurrentWordSoundsWord(null); setWordSoundsPhonemes(null); setWordSoundsFeedback(null); setWordSoundsActivity(null); setWordSou

=== currentWordIndex modulo wrapping ===
L11362: const firstWord = preloadedWords[currentWordIndex % Math.max(1, preloadedWords.length)];

=== setWsPreloadedWords ===
L4616: wsPreloadedWords = [],
L4617: setWsPreloadedWords,
L4742: const preloadedWords = wsPreloadedWords || [];
L4743: const setPreloadedWords = setWsPreloadedWords || (() => {
L4744: console.warn("setWsPreloadedWords is not defined - updates won't persist");
L7156: if (setWsPreloadedWords) {
L7157: setWsPreloadedWords(prev => prev.map(w =>
L7167: if (setWsPreloadedWords) {
L7168: setWsPreloadedWords(prev => prev.map(pw => {
L7179: }, [preloadedWords, handleAudio, setWsPreloadedWords]);
L7196: if (setWsPreloadedWords) {
L7197: setWsPreloadedWords(newOrder);
L7198: debugLog("‚úÖ Reordered words via setWsPreloadedWords");
L7203: }, [setWsPreloadedWords]);
L7207: if (setWsPreloadedWords) {
L7208: setWsPreloadedWords(prev => {
L7214: debugLog("‚úÖ Updated word at index", index, "via setWsPreloadedWords");
L7238: debugLog("üóëÔ∏è DELETE: Attempting to remove word at index:", idx, "setWsPreloadedWords defined:", !!setWsPreloadedWords);
L7256: const usedLifted = performDelete(setWsPreloadedWords, 'setWsPreloadedWords');
L7267: }, [setWsPreloadedWords]);
L7324: if (setWsPreloadedWords) {
L7325: setWsPreloadedWords(prev => {
L7347: }, [preloadedWords, fetchWordData, setWsPreloadedWords, handleAudio]);
L7368: setWsPreloadedWords(prev => {
L7385: }, [preloadedWords, callGemini, setWsPreloadedWords, handleAudio]); // Removed showError dependency if not stable, but it's likely stable
L7423: const setter = setWsPreloadedWords || setPreloadedWords;
L7432: }, [preloadedWords, fetchWordData, setWsPreloadedWords, setPreloadedWords, addToast]);
L32924: wsPreloadedWords: [],
L34061: const { wsPreloadedWords, wsActivitySequence, wordSoundsDifficulty, wordSoundsAccuracyHistory, wordSoundsStreak, wordSoundsSessionGoal, orthoSessionGoal, wordSoundsSessionProgress,
L34062: const setWsPreloadedWords = (v) => wsDispatch({ type: 'WS_SET', field: 'wsPreloadedWords', value: v });
L36864: // Persist wsPreloadedWords to currently active glossary/word-sounds history item
L36866: if (!generatedContent || wsPreloadedWords.length === 0) return;
L36872: // Only update if wsPreloadedWords has changed
L36873: if (JSON.stringify(prev[idx].wsPreloadedWords) === JSON.stringify(wsPreloadedWords)) return prev;
L36875: updated[idx] = { ...updated[idx], wsPreloadedWords };
L36876: // SILENCED: debugLog("üíæ Persisted preloaded words to history item:", wsPreloadedWords.length, "words");
L36879: }, [wsPreloadedWords, generatedContent]);
L36884: if (wsPreloadedWords.length > 0 && prevWsPreloadedWordsLengthRef.current === 0) {
L36885: debugLog("üöÄ Auto-opening Word Sounds mode for", wsPreloadedWords.length, "preloaded words");
L36889: prevWsPreloadedWordsLengthRef.current = wsPreloadedWords.length;
L36890: }, [wsPreloadedWords.length]);
L47213: if (item.wsPreloadedWords && Array.isArray(item.wsPreloadedWords) && item.wsPreloadedWords.length > 0) {
L47214: debugLog("üì• Restoring preloaded words from saved wsPreloadedWords:", item.wsPreloadedWords.length);
L47216: const wordsWithFreshTtsFlags = item.wsPreloadedWords.map(w => ({
L47221: setWsPreloadedWords(wordsWithFreshTtsFlags);
L47226: setWsPreloadedWords(item.data);
L47281: setGeneratedContent(newItem); setWordSoundsCustomTerms(generatedTerms); setWsPreloadedWords(generatedTerms); // FIX: Sync preloaded state
L58258: setGeneratedContent(newItem); setWordSoundsCustomTerms(generatedTerms); setWsPreloadedWords(generatedTerms); // FIX: Sync preloaded state
L65836: {isWordSoundsMode && (generatedContent?.type === 'glossary' || generatedContent?.type === 'word-sounds' || (wsPreloadedWords && wsPreloadedWords.length > 0)) && (
L65844: wsPreloadedWords={wsPreloadedWords}
L65847: setWsPreloadedWords={setWsPreloadedWords}
L72429: setWsPreloadedWords(words);
L72440: preloadedWords={wsPreloadedWords || []}

=== preloadInitialBatch definition + completion ===
L6730: const preloadInitialBatch = React.useCallback(async () => {
L6734: debugLog("üõ°Ô∏è Blocking preloadInitialBatch: words already loaded");
L7137: // DISABLED: preloadInitialBatch is blocking and redundant.
L7141: preloadInitialBatch();
L7144: }, [wordPool, preloadedWords.length, isPreloading, preloadInitialBatch]);
L7146: // Ensures audio is available even if we skipped the blocking preloadInitialBatch
L8108: // FIX: Also call preloadInitialBatch if not already running
L8109: if (typeof preloadInitialBatch === 'function') {
L8110: preloadInitialBatch();
L8903: // FIX: Extract with correct property names from preloadInitialBatch structure
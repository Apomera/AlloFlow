
--- prefetchNextWords (9 matches) ---
  L5326: const prefetchNextWords = React.useCallback(async () => {
  L5741: // We rely on the useEffect at line ~3004 to start the activity and trigger prefetchNextWords().
  L6180: const timer = setTimeout(() => prefetchNextWords(), 1000);
  L6183: }, [wordSoundsPhonemes, nextWordBuffer, isLoadingPhonemes, prefetchNextWords]);
  L6389: // SKIP if options were already pre-generated by fetchWordData or prefetchNextWords
  L6663: prefetchNextWords();
  L6670: }, [wordPool, currentWordSoundsWord, wordSoundsActivity, startActivity, isLoadingPhonemes, prefetchNextWords, showReviewPanel, pre
  L7483: setTimeout(() => prefetchNextWords(), 100);
  L7585: nextWordBuffer, preloadedWords, prefetchNextWords, generateSoundChips]); // Added dependencies

--- prefetch (16 matches) ---
  L1708: // Execute prefetch
  L5326: const prefetchNextWords = React.useCallback(async () => {
  L5380: const prefetchPromises = wordsToPreload.map(async (wordEntry, i) => {
  L5700: const results = await Promise.all(prefetchPromises);
  L5741: // We rely on the useEffect at line ~3004 to start the activity and trigger prefetchNextWords().
  L5767: await handleAudio(text, false).catch(e => warnLog("Audio prefetch failed:", e));
  L5778: warnLog(`Audio prefetch failed for ${text}`, e);
  L6176: // Trigger prefetch when current word is loaded and stable
  L6180: const timer = setTimeout(() => prefetchNextWords(), 1000);
  L6183: }, [wordSoundsPhonemes, nextWordBuffer, isLoadingPhonemes, prefetchNextWords]);
  L6389: // SKIP if options were already pre-generated by fetchWordData or prefetchNextWords
  L6663: prefetchNextWords();
  L6670: }, [wordPool, currentWordSoundsWord, wordSoundsActivity, startActivity, isLoadingPhonemes, prefetchNextWords, showReviewPanel, pre
  L7470: // FIX: Set isolation options from prefetched data
  L7483: setTimeout(() => prefetchNextWords(), 100);

--- ttsReady (13 matches) ---
  L2337: // Accessing global audioInstances if available, or just treating 'ttsReady' flag if I had one.
  L2339: // I will rely on the fact that preloadedWords might be updated with ttsReady,
  L2345: ready: preloadedWords.filter(w => w.ttsReady || w.phonemes).length, // Proxy
  L2773: disabled={playingWordIndex !== null || !word.ttsReady}
  L2781: title={playingWordIndex === idx ? "Playing..." : !word.ttsReady ? "Loading audio..." : "Play word"}
  L5409: return { ...wordEntry, ttsReady: true, difficulty: wordEntry.difficulty || categorizeWordDifficulty(targetWord) };
  L5693: ttsReady: true
  L5754: const wordsNeedingAudio = preloadedWords.filter(w => !w.ttsReady && !w._audioRequested);
  L5772: return { ...pw, ttsReady: true, _audioRequested: false };
  L5785: // FIX: Wait until words have ttsReady=true (not just phonemes - ensures audio works immediately)
  L5788: const readyWords = preloadedWords.filter(w => w.ttsReady === true);
  L42766: // FIX: Clear ttsReady to force TTS re-cache (audio data not persisted)
  L42769: ttsReady: false,

--- blendingDistractors (28 matches) ---
  L1637: "blendingDistractors": ["cord", "core", "born", "worn", "torn"],
  L1676: blendingDistractors: data.blendingDistractors || [],
  L1706: (lastItem.blendingDistractors || []).forEach(w => w && ttsTasks.add(w));
  L3035: {(word.blendingDistractors || []).map((d, i) => (
  L3040: const newDist = [...word.blendingDistractors];
  L3042: onUpdateWord(idx, { ...word, blendingDistractors: newDist });
  L3064: await onRegenerateOption(idx, 'blendingDistractors', i, d);
  L3078: const newDist = [...(word.blendingDistractors || []), ''];
  L3079: onUpdateWord(idx, { ...word, blendingDistractors: newDist });
  L4661: blendingDistractors: term.blendingDistractors,
  L5039: if (wordSoundsActivity === 'blending' && data.blendingDistractors && setBlendingOptions) {
  L5043: data.blendingDistractors
  L5165: const blendingDistractors = [];
  L5180: if (w !== wordLower && Math.abs(w.length - wordLower.length) <= 1 && blendingDistractors.length < 5) {
  L5181: blendingDistractors.push(w);